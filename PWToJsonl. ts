// tools/jsonl/playwright-to-jsonl.ts

import fs from "fs"
import path from "path"
import crypto from "crypto"

type Status = "passed" | "failed" | "skipped" | "unknown"

type PlaywrightEvent = {
  test_id: string
  tool: "playwright"
  status: Status
  duration_ms: number
  timestamp_utc: string
  test_name: string
  test_path: string
  error_message: string
}

type PlaywrightError = {
  message?: string
  value?: string
}

type PlaywrightResult = {
  status?: string
  outcome?: string
  duration?: number
  error?: PlaywrightError
  errors?: PlaywrightError[]
}

type PlaywrightTest = {
  title?: string
  results?: PlaywrightResult[]
}

type PlaywrightSpec = {
  title?: string
  file?: string
  tests?: PlaywrightTest[]
}

type PlaywrightSuite = {
  specs?: PlaywrightSpec[]
  suites?: PlaywrightSuite[]
}

type PlaywrightJsonReport = {
  suites?: PlaywrightSuite[]
}

const DEFAULT_INPUT_PATH = "test-results/playwright-report.json"
const DEFAULT_OUTPUT_PATH = "test-results/playwright-events.jsonl"
const MAX_ERROR_LENGTH = 800
const HASH_LENGTH = 10

function logInfo(message: string): void {
  if (process.env.DEBUG_JSONL === "1") {
    // eslint-disable-next-line no-console
    console.log(message)
  }
}

function ensureParentDir(filePath: string): void {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
}

function asString(value: unknown): string {
  if (value === null || value === undefined) return ""
  return String(value)
}

function truncate(text: string, maxLen: number): string {
  if (text.length <= maxLen) return text
  return text.slice(0, maxLen)
}

function hashId(input: string): string {
  return crypto.createHash("sha256").update(input).digest("hex").slice(0, HASH_LENGTH)
}

function toStatus(result: PlaywrightResult | undefined): Status {
  const raw = asString(result?.outcome || result?.status)

  if (raw === "expected" || raw === "passed") return "passed"
  if (raw === "skipped") return "skipped"
  if (raw === "unexpected" || raw === "failed" || raw === "timedOut") return "failed"
  if (raw === "flaky") return "failed"

  return "unknown"
}

function errorMessageFrom(result: PlaywrightResult | undefined): string {
  const direct = asString(result?.error?.message)
  if (direct) return truncate(direct, MAX_ERROR_LENGTH)

  const errors = Array.isArray(result?.errors) ? result.errors : []
  if (!errors.length) return ""

  const first = errors[0]
  return truncate(asString(first?.message || first?.value), MAX_ERROR_LENGTH)
}

function safeReadJsonReport(filePath: string): PlaywrightJsonReport | null {
  try {
    const raw = fs.readFileSync(filePath, "utf8")
    return JSON.parse(raw) as PlaywrightJsonReport
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err)
    logInfo(`Failed to read or parse ${filePath}. ${message}`)
    process.exitCode = 1
    return null
  }
}

function writeJsonl(filePath: string, events: PlaywrightEvent[]): void {
  const content = events.map((e) => JSON.stringify(e)).join("\n") + "\n"
  fs.writeFileSync(filePath, content, "utf8")
}

function collectSpecs(rootSuites: PlaywrightSuite[]): PlaywrightSpec[] {
  const specs: PlaywrightSpec[] = []
  const stack: PlaywrightSuite[] = [...rootSuites]

  while (stack.length) {
    const suite = stack.pop()
    if (!suite) break

    const suiteSpecs = Array.isArray(suite.specs) ? suite.specs : []
    for (const spec of suiteSpecs) specs.push(spec)

    const children = Array.isArray(suite.suites) ? suite.suites : []
    for (const child of children) stack.push(child)
  }

  return specs
}

function toEvents(specs: PlaywrightSpec[], timestampUtc: string): PlaywrightEvent[] {
  const events: PlaywrightEvent[] = []

  for (const spec of specs) {
    const testPath = asString(spec.file)
    const specTitle = asString(spec.title)

    const tests = Array.isArray(spec.tests) ? spec.tests : []
    for (const test of tests) {
      const testTitle = asString(test.title)
      const testName = [specTitle, testTitle].filter(Boolean).join(" ").trim()

      const results: PlaywrightResult[] = Array.isArray(test.results) ? test.results : []
      const lastResult = results.length ? results[results.length - 1] : undefined

      events.push({
        test_id: hashId(`${testPath}::${testName}`),
        tool: "playwright",
        status: toStatus(lastResult),
        duration_ms: typeof lastResult?.duration === "number" ? lastResult.duration : 0,
        timestamp_utc: timestampUtc,
        test_name: testName,
        test_path: testPath,
        error_message: errorMessageFrom(lastResult),
      })
    }
  }

  return events
}

function main(): void {
  const inputPath = process.argv[2] || DEFAULT_INPUT_PATH
  const outputPath = process.argv[3] || DEFAULT_OUTPUT_PATH

  const report = safeReadJsonReport(inputPath)
  if (!report) return

  const timestampUtc = new Date().toISOString()
  const rootSuites = Array.isArray(report.suites) ? report.suites : []
  const specs = collectSpecs(rootSuites)
  const events = toEvents(specs, timestampUtc)

  ensureParentDir(outputPath)
  writeJsonl(outputPath, events)

  logInfo(`Wrote ${events.length} Playwright events to ${outputPath}`)
}

main()