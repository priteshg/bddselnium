import crypto from "crypto"
import { writeFileSync } from "fs"
import { relative } from "path"
import type { AggregatedResult, Reporter, Test, TestResult } from "@jest/reporters"

type ReporterOptions = {
  outputFile?: string
}

type Status = "passed" | "failed" | "skipped" | "unknown"

type OutputRow = {
  id: string
  name: string
  status: Status
  file: string
  durationMs: number
  errorMessage: string
}

function asText(value: unknown): string {
  return typeof value === "string" ? value : String(value ?? "")
}

function normalizeStatus(value: unknown): Status {
  const s = asText(value)
  if (s === "passed") return "passed"
  if (s === "failed") return "failed"
  if (s === "skipped") return "skipped"
  if (s === "pending") return "skipped"
  if (s === "todo") return "skipped"
  if (s === "disabled") return "skipped"
  return "unknown"
}

function stableHash(value: string): string {
  return crypto.createHash("sha1").update(value).digest("hex").slice(0, 10)
}

function cleanName(raw: string): string {
  return raw.replace(/[\{\[\(\=\:\;].*$/, "").trim()
}

function pickFailureMessage(entry: { failureMessages?: unknown }): string {
  const msgs = entry.failureMessages
  if (!Array.isArray(msgs) || msgs.length === 0) return ""
  return asText(msgs[0])
}

export default class CustomJestReporter implements Reporter {
  private readonly outputFile: string
  private readonly rows: OutputRow[] = []

  public constructor(_globalConfig: unknown, options?: ReporterOptions) {
    this.outputFile = options?.outputFile || "jest-report.json"
  }

  public onTestResult(_test: Test, testResult: TestResult): void {
    const file = relative(process.cwd(), testResult.testFilePath)
    const entries = Array.isArray(testResult.testResults) ? testResult.testResults : []

    for (const entry of entries) {
      const fullName = asText(entry.fullName || entry.title)
      const id = `${file}::${stableHash(`${file}::${fullName}`)}`
      const status = normalizeStatus(entry.status)

      const durationMs = Number.isFinite(entry.duration) ? Number(entry.duration) : 0
      const errorMessage = status === "failed" ? pickFailureMessage(entry) : ""

      this.rows.push({
        id,
        name: cleanName(fullName),
        status,
        file,
        durationMs,
        errorMessage,
      })
    }
  }

  public onRunComplete(_contexts: Set<unknown>, _results: AggregatedResult): void {
    writeFileSync(this.outputFile, JSON.stringify(this.rows, null, 2), "utf8")
  }
}